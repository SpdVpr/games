<!DOCTYPE html>
<html lang="cs">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple 3D Tower Defense</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: sans-serif; background-color: #222; color: white; }
        canvas { display: block; }
        #ui { position: absolute; top: 10px; left: 10px; background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; }
        #info { position: absolute; bottom: 10px; left: 10px; }
        #build-panel { position: absolute; top: 10px; right: 10px; background-color: rgba(0,0,0,0.7); padding: 10px; border-radius: 5px; }
        button { margin: 5px; padding: 8px 12px; cursor: pointer; }
        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(200, 0, 0, 0.8);
            padding: 30px;
            border-radius: 10px;
            font-size: 2em;
            text-align: center;
            display: none; /* Initially hidden */
            z-index: 100;
        }
    </style>
</head>
<body>

    <div id="ui">
        <div>Peníze: <span id="money">100</span></div>
        <div>Životy: <span id="health">20</span></div>
        <div>Vlna: <span id="wave">0</span></div>
    </div>

    <div id="build-panel">
        <div>Stavba (Cena: <span id="tower-cost">50</span>)</div>
        <button id="build-tower-btn">Postavit věž</button>
        <div id="build-message" style="font-size: 0.8em; color: yellow;"></div>
    </div>

    <div id="info">
        Ovládání: Pravé tlačítko myši + táhnutí = otáčení kamery, Kolečko = zoom, Levé tlačítko = interakce/stavba
    </div>

    <div id="game-over">
        KONEC HRY!
        <br>
        <button onclick="location.reload()">Hrát znovu</button>
    </div>

    <!-- CDN Imports - required for the game to run -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
                 "cannon-es": "https://unpkg.com/cannon-es@0.20.0/dist/cannon-es.js",
                 "cannon-es-debugger": "https://unpkg.com/cannon-es-debugger@1.0.0/dist/cannon-es-debugger.js"
            }
        }
    </script>

    <script type="module">
        // Import necessary libraries
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import * as CANNON from 'cannon-es';
        // Optional: Debugger for visualizing physics shapes
        // import CannonDebugger from 'cannon-es-debugger';

        // --- Global Variables ---
        let scene, camera, renderer, controls, clock;
        let physicsWorld, cannonDebugger; // Optional debugger
        const gameObjects = []; // To keep track of Three.js meshes and Cannon.js bodies
        const enemies = [];
        const towers = [];
        const projectiles = [];

        // Game State
        let money = 100;
        let health = 20;
        let wave = 0;
        let enemiesToSpawn = 0;
        let spawnTimer = 0;
        const SPAWN_INTERVAL = 2; // seconds
        const TOWER_COST = 50;
        let buildMode = false;
        let placementIndicator;
        let raycaster, mouse;
        let gameOver = false;

        // Physics materials
        let groundMaterial, enemyMaterial, projectileMaterial, towerMaterial;

        // Path for enemies (simple straight line for this example)
        const pathPoints = [
            new THREE.Vector3(-40, 0.5, 0),
            new THREE.Vector3(40, 0.5, 0)
        ];
        const pathEndThreshold = 1.0; // How close enemy needs to be to the end point

        // --- Initialization ---
        function init() {
            clock = new THREE.Clock();

            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xaaaaaa);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 30, 35);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true; // Enable shadows
            document.body.appendChild(renderer.domElement);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0);
            directionalLight.position.set(10, 20, 5);
            directionalLight.castShadow = true; // Enable shadow casting
            // Configure shadow properties for better quality (optional)
            directionalLight.shadow.mapSize.width = 1024;
            directionalLight.shadow.mapSize.height = 1024;
            directionalLight.shadow.camera.near = 0.5;
            directionalLight.shadow.camera.far = 50;
            directionalLight.shadow.camera.left = -30;
            directionalLight.shadow.camera.right = 30;
            directionalLight.shadow.camera.top = 30;
            directionalLight.shadow.camera.bottom = -30;
            scene.add(directionalLight);
            // scene.add(new THREE.CameraHelper(directionalLight.shadow.camera)); // Helper to visualize shadow camera


            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.enablePan = false; // Disable panning for simpler TD feel
            controls.maxPolarAngle = Math.PI / 2.1; // Limit looking down too much


            // Physics World (CANNON-es)
            physicsWorld = new CANNON.World({
                gravity: new CANNON.Vec3(0, -9.82, 0) // Standard gravity
            });

             // Optional: Physics Debugger
            // cannonDebugger = new CannonDebugger(scene, physicsWorld, {});


            // --- Physics Materials ---
            groundMaterial = new CANNON.Material("groundMaterial");
            enemyMaterial = new CANNON.Material("enemyMaterial");
            projectileMaterial = new CANNON.Material("projectileMaterial");
            towerMaterial = new CANNON.Material("towerMaterial");

            // Contact Materials (how materials interact)
            const groundEnemyContact = new CANNON.ContactMaterial(groundMaterial, enemyMaterial, {
                friction: 0.1,
                restitution: 0.3 // Slight bounce
            });
            physicsWorld.addContactMaterial(groundEnemyContact);

            const groundProjectileContact = new CANNON.ContactMaterial(groundMaterial, projectileMaterial, {
                friction: 0.5,
                restitution: 0.1 // Less bounce
            });
            physicsWorld.addContactMaterial(groundProjectileContact);

            const enemyProjectileContact = new CANNON.ContactMaterial(enemyMaterial, projectileMaterial, {
                friction: 0,
                restitution: 0.1 // Very little bounce on hit
            });
            physicsWorld.addContactMaterial(enemyProjectileContact);

            const towerProjectileContact = new CANNON.ContactMaterial(towerMaterial, projectileMaterial, {
                friction: 0,
                restitution: 0.1
            });
            physicsWorld.addContactMaterial(towerProjectileContact);

             // --- Game Objects ---
            createGround();
            createPathVisualization(); // Optional: visualize the path

            // Raycaster for placement
            raycaster = new THREE.Raycaster();
            mouse = new THREE.Vector2();

            // UI Setup
            document.getElementById('tower-cost').innerText = TOWER_COST;
            document.getElementById('build-tower-btn').addEventListener('click', toggleBuildMode);
            window.addEventListener('resize', onWindowResize);
            window.addEventListener('mousemove', onMouseMove);
            window.addEventListener('click', onMouseClick);

            // Start game logic
            updateUI();
            startNextWave(); // Start the first wave
            animate(); // Start the main loop
        }

        // --- Ground ---
        function createGround() {
            // Three.js visual plane
            const groundGeometry = new THREE.PlaneGeometry(100, 100);
            const groundMaterialVisual = new THREE.MeshStandardMaterial({ color: 0x88cc88, side: THREE.DoubleSide });
            const groundMesh = new THREE.Mesh(groundGeometry, groundMaterialVisual);
            groundMesh.rotation.x = -Math.PI / 2; // Rotate flat
            groundMesh.receiveShadow = true; // Allow ground to receive shadows
            scene.add(groundMesh);

            // Cannon.js physics plane
            const groundShape = new CANNON.Plane();
            const groundBody = new CANNON.Body({
                mass: 0, // Static object
                material: groundMaterial,
                shape: groundShape
            });
            groundBody.quaternion.setFromEuler(-Math.PI / 2, 0, 0); // Match visual rotation
            physicsWorld.addBody(groundBody);
        }

        // --- Path Visualization (Optional) ---
         function createPathVisualization() {
            const pathMaterial = new THREE.LineBasicMaterial({ color: 0xffd700, linewidth: 2 }); // Gold color
            const points = [];
             // Add slight elevation to see it above ground
            points.push(new THREE.Vector3(pathPoints[0].x, 0.1, pathPoints[0].z));
            points.push(new THREE.Vector3(pathPoints[1].x, 0.1, pathPoints[1].z));

            const pathGeometry = new THREE.BufferGeometry().setFromPoints(points);
            const pathLine = new THREE.Line(pathGeometry, pathMaterial);
            scene.add(pathLine);
        }


        // --- Enemy ---
        function createEnemy() {
            const size = 1.0;
            // Three.js visual cube
            const geometry = new THREE.BoxGeometry(size, size, size);
            const material = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // Red
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.position.copy(pathPoints[0]); // Start at the beginning of the path
            scene.add(mesh);

            // Cannon.js physics body
            const shape = new CANNON.Box(new CANNON.Vec3(size / 2, size / 2, size / 2));
            const body = new CANNON.Body({
                mass: 5, // Give it some mass
                material: enemyMaterial,
                shape: shape,
                position: new CANNON.Vec3(mesh.position.x, mesh.position.y, mesh.position.z),
                linearDamping: 0.5 // Add some damping to prevent sliding forever
            });
            body.position.y = size / 2 + 0.1; // Ensure it starts slightly above ground
             // Prevent rotation for stability
            body.angularDamping = 1.0;
            physicsWorld.addBody(body);


            const enemy = {
                mesh: mesh,
                body: body,
                health: 100 + wave * 10, // Increase health with waves
                speed: 2.0 + wave * 0.1, // Increase speed slightly
                pathIndex: 0,
                isEnemy: true // Identifier
            };

            // Collision handling for enemy
            body.addEventListener('collide', (event) => {
                // Check if collided with a projectile
                const otherBody = event.body;
                const contact = event.contact;

                // Find the projectile object associated with the otherBody
                 const projectile = projectiles.find(p => p.body === otherBody);

                 if (projectile && !projectile.hit) { // Check if it's a projectile and hasn't hit yet
                    enemy.health -= projectile.damage;
                    projectile.hit = true; // Mark projectile as hit to prevent multiple damage
                    // console.log(`Enemy hit! Health: ${enemy.health}`);

                    // Remove projectile shortly after impact
                    setTimeout(() => removeProjectile(projectile), 50); // Short delay before removal

                    if (enemy.health <= 0) {
                        // console.log("Enemy destroyed!");
                        money += 10; // Award money
                        removeEnemy(enemy);
                        updateUI();
                    }
                }
            });

            enemies.push(enemy);
            gameObjects.push(enemy); // Track for updates
            return enemy;
        }

        function removeEnemy(enemy) {
            // Remove from scene and physics world
            scene.remove(enemy.mesh);
            physicsWorld.removeBody(enemy.body);

            // Remove from arrays
            const gameIndex = gameObjects.indexOf(enemy);
            if (gameIndex > -1) gameObjects.splice(gameIndex, 1);
            const enemyIndex = enemies.indexOf(enemy);
            if (enemyIndex > -1) enemies.splice(enemyIndex, 1);

            // Dispose geometry and material to free memory (important!)
             if (enemy.mesh.geometry) enemy.mesh.geometry.dispose();
             if (enemy.mesh.material) enemy.mesh.material.dispose();

        }

        function updateEnemies(deltaTime) {
            for (let i = enemies.length - 1; i >= 0; i--) {
                const enemy = enemies[i];

                // Move towards the next path point
                 // Simplified: Directly control velocity towards the target point
                 // More robust physics would involve applying forces, but this is simpler for TD path following

                const targetPoint = pathPoints[enemy.pathIndex + 1] || pathPoints[pathPoints.length - 1]; // Get next or last point
                const direction = new CANNON.Vec3();
                targetPoint.clone().sub(enemy.body.position, direction); // Vector from enemy to target
                direction.y = 0; // Keep movement on the horizontal plane
                direction.normalize();

                // Apply velocity directly (simpler than forces for precise path following)
                enemy.body.velocity.set(
                    direction.x * enemy.speed,
                    enemy.body.velocity.y, // Keep existing vertical velocity (gravity)
                    direction.z * enemy.speed
                );


                 // Check if enemy reached the target point (or close enough)
                const distanceToTarget = enemy.body.position.distanceTo(targetPoint);

                 if (enemy.pathIndex < pathPoints.length - 1 && distanceToTarget < 1.0) {
                     enemy.pathIndex++;
                 }


                // Check if enemy reached the end of the path
                 const distanceToEnd = enemy.body.position.distanceTo(pathPoints[pathPoints.length - 1]);
                 if (distanceToEnd < pathEndThreshold) {
                    // console.log("Enemy reached the end!");
                    health -= 1; // Player loses health
                    removeEnemy(enemy);
                    updateUI();
                    if (health <= 0 && !gameOver) {
                        triggerGameOver();
                    }
                }
            }
        }

        // --- Tower ---
         const TOWER_RANGE = 15;
         const TOWER_FIRE_RATE = 1.0; // Shots per second
         const PROJECTILE_DAMAGE = 35;
         const PROJECTILE_SPEED = 30;

         function createTower(position) {
            if (money < TOWER_COST) {
                console.log("Not enough money!");
                setBuildMessage("Nedostatek peněz!", "red");
                return null; // Indicate failure
            }

            const size = 1.5;
            const height = 3;
            // Three.js visual cylinder
            const geometry = new THREE.CylinderGeometry(size/2, size * 0.8, height, 16);
            const material = new THREE.MeshStandardMaterial({ color: 0x0000ff }); // Blue
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;
            mesh.position.copy(position);
            mesh.position.y = height / 2; // Place base on the ground
            scene.add(mesh);

             // Cannon.js physics body (static)
             // Use a Box shape which is often more stable than Cylinder in Cannon
            const shape = new CANNON.Box(new CANNON.Vec3(size * 0.8 / 2, height / 2, size * 0.8 / 2));
            const body = new CANNON.Body({
                mass: 0, // Static
                material: towerMaterial,
                shape: shape,
                position: new CANNON.Vec3(mesh.position.x, mesh.position.y, mesh.position.z),
            });
            physicsWorld.addBody(body);

            const tower = {
                mesh: mesh,
                body: body, // Add physics body
                range: TOWER_RANGE,
                fireRate: TOWER_FIRE_RATE,
                cooldown: 0,
                target: null,
                isTower: true // Identifier
            };

             // Deduct cost and add tower
            money -= TOWER_COST;
            towers.push(tower);
            gameObjects.push(tower); // Also track tower for potential future updates if needed
            updateUI();
            setBuildMessage(`Věž postavena! Zbývá peněz: ${money}`, "lightgreen");
            return tower; // Indicate success
        }

         function updateTowers(deltaTime) {
             towers.forEach(tower => {
                // Cooldown update
                if (tower.cooldown > 0) {
                    tower.cooldown -= deltaTime;
                }

                // Target acquisition
                if (!tower.target || tower.target.health <= 0 || tower.mesh.position.distanceTo(tower.target.mesh.position) > tower.range) {
                    tower.target = findNearestEnemyInRange(tower);
                }

                 // Firing
                 if (tower.target && tower.cooldown <= 0) {
                    fireProjectile(tower, tower.target);
                    tower.cooldown = 1 / tower.fireRate; // Reset cooldown
                }

                 // Optional: Aim tower towards target (visual only)
                // if (tower.target) {
                //    tower.mesh.lookAt(tower.target.mesh.position.x, tower.mesh.position.y, tower.target.mesh.position.z); // LookAt on Y plane
                // }
            });
        }

         function findNearestEnemyInRange(tower) {
             let nearestEnemy = null;
             let minDistanceSq = tower.range * tower.range; // Use squared distance for efficiency

            enemies.forEach(enemy => {
                if (enemy.health > 0) {
                     // Use physics body positions for accurate distance checking
                    const distanceSq = tower.body.position.distanceSquared(enemy.body.position);
                    if (distanceSq < minDistanceSq) {
                        minDistanceSq = distanceSq;
                        nearestEnemy = enemy;
                    }
                }
            });
            return nearestEnemy;
        }


        // --- Projectile ---
        function fireProjectile(tower, target) {
            const projectileSize = 0.3;
            // Three.js visual sphere
            const geometry = new THREE.SphereGeometry(projectileSize, 8, 8);
            const material = new THREE.MeshStandardMaterial({ color: 0xffff00 }); // Yellow
            const mesh = new THREE.Mesh(geometry, material);
            mesh.castShadow = true;

            // Cannon.js physics body
            const shape = new CANNON.Sphere(projectileSize);
            const body = new CANNON.Body({
                mass: 0.5, // Low mass
                material: projectileMaterial,
                shape: shape,
                linearDamping: 0.01, // Very slight air resistance
                angularDamping: 0.1 // Some spin decay
            });

             // Calculate initial position (slightly above the tower)
             const spawnPos = tower.body.position.clone();
             spawnPos.y += tower.mesh.geometry.parameters.height / 2 + projectileSize + 0.1; // Start above tower top

             mesh.position.copy(spawnPos);
             body.position.copy(spawnPos);


            // Calculate initial velocity direction towards the target
            const direction = new CANNON.Vec3();
            target.body.position.clone().sub(spawnPos, direction);
            direction.normalize();

            // Apply initial velocity
            body.velocity.set(
                direction.x * PROJECTILE_SPEED,
                direction.y * PROJECTILE_SPEED, // Account for vertical angle
                direction.z * PROJECTILE_SPEED
            );

            scene.add(mesh);
            physicsWorld.addBody(body);

            const projectile = {
                mesh: mesh,
                body: body,
                damage: PROJECTILE_DAMAGE,
                targetBody: target.body, // Store reference to target's physics body
                startTime: clock.getElapsedTime(),
                isProjectile: true, // Identifier
                hit: false // Track if it has hit something
            };

             // Self-destruct timer for projectiles that miss or don't collide
            const MAX_PROJECTILE_LIFETIME = 3.0; // seconds
            setTimeout(() => {
                if (!projectile.hit) { // Only remove if it hasn't hit
                    removeProjectile(projectile);
                }
            }, MAX_PROJECTILE_LIFETIME * 1000);

            projectiles.push(projectile);
            gameObjects.push(projectile); // Track for updates
        }


         function removeProjectile(projectile) {
             // Check if already removed
             if (!projectile || !projectile.mesh || !projectile.body) return;

             scene.remove(projectile.mesh);
             physicsWorld.removeBody(projectile.body);

             // Remove from arrays
             const gameIndex = gameObjects.indexOf(projectile);
             if (gameIndex > -1) gameObjects.splice(gameIndex, 1);
             const projIndex = projectiles.indexOf(projectile);
             if (projIndex > -1) projectiles.splice(projIndex, 1);

             // Dispose geometry and material
             if (projectile.mesh.geometry) projectile.mesh.geometry.dispose();
             if (projectile.mesh.material) projectile.mesh.material.dispose();

             // Nullify references to help garbage collection
             projectile.mesh = null;
             projectile.body = null;
         }

        // --- Game Loop ---
        function animate() {
             if (gameOver) return; // Stop loop if game over

            requestAnimationFrame(animate);
            const deltaTime = clock.getDelta();

            // 1. Update Physics World
            physicsWorld.step(1 / 60, deltaTime, 3); // Fixed timestep, delta, maxsubsteps

            // 2. Update Game Logic
            handleSpawning(deltaTime);
            updateEnemies(deltaTime);
            updateTowers(deltaTime);
            // Projectile position is handled by physics sync below

            // 3. Synchronize Three.js visuals with Cannon.js physics
            gameObjects.forEach(obj => {
                if (obj.mesh && obj.body) {
                    obj.mesh.position.copy(obj.body.position);
                    obj.mesh.quaternion.copy(obj.body.quaternion);
                }
            });

            // 4. Update Controls
            controls.update(deltaTime);

             // Optional: Update Physics Debugger
            // cannonDebugger.update();

            // 5. Render Scene
            renderer.render(scene, camera);
        }

        // --- Wave Management ---
        function startNextWave() {
            wave++;
            enemiesToSpawn = 5 + wave * 3; // Simple scaling
            spawnTimer = SPAWN_INTERVAL; // Start timer for first spawn
            // console.log(`Starting Wave ${wave}, Enemies: ${enemiesToSpawn}`);
            updateUI();
        }

        function handleSpawning(deltaTime) {
            if (enemiesToSpawn > 0) {
                spawnTimer -= deltaTime;
                if (spawnTimer <= 0) {
                    createEnemy();
                    enemiesToSpawn--;
                    spawnTimer = SPAWN_INTERVAL; // Reset timer
                }
            } else if (enemies.length === 0) {
                // If no enemies left to spawn and no enemies on map, start next wave
                startNextWave();
            }
        }


        // --- Building Logic ---
         function toggleBuildMode() {
            buildMode = !buildMode;
            if (buildMode) {
                if (money < TOWER_COST) {
                     setBuildMessage(`Nedostatek peněz (potřeba ${TOWER_COST})`, "red");
                     buildMode = false; // Can't enter build mode if not enough money
                     return;
                }
                document.getElementById('build-tower-btn').innerText = 'Zrušit stavbu';
                document.getElementById('build-tower-btn').style.backgroundColor = 'orange';
                 setBuildMessage("Vyberte místo pro věž kliknutím na zem.", "yellow");

                // Create placement indicator
                if (!placementIndicator) {
                    const indicatorGeo = new THREE.CylinderGeometry(TOWER_RANGE, TOWER_RANGE, 0.2, 32, 1, true); // Ring shape for range
                    const indicatorMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true, transparent: true, opacity: 0.5 });
                    placementIndicator = new THREE.Mesh(indicatorGeo, indicatorMat);
                    placementIndicator.visible = false; // Initially hidden
                    scene.add(placementIndicator);
                }
            } else {
                document.getElementById('build-tower-btn').innerText = `Postavit věž`;
                 document.getElementById('build-tower-btn').style.backgroundColor = ''; // Reset color
                 setBuildMessage(""); // Clear message
                if (placementIndicator) {
                    placementIndicator.visible = false;
                }
            }
        }

         function setBuildMessage(text, color = "yellow") {
             const msgElement = document.getElementById('build-message');
             msgElement.innerText = text;
             msgElement.style.color = color;
             // Optionally clear message after a delay
              if (text !== "") {
                  setTimeout(() => {
                      if (msgElement.innerText === text) { // Only clear if message hasn't changed
                          // msgElement.innerText = ""; // Decide if you want it to auto-clear
                      }
                  }, 3000); // Clear after 3 seconds
              }
         }


        // --- Event Handlers ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(event) {
            // Calculate mouse position in normalized device coordinates (-1 to +1)
            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            if (buildMode && placementIndicator) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([scene.children.find(c => c.geometry instanceof THREE.PlaneGeometry)]); // Intersect only ground plane

                if (intersects.length > 0) {
                    const intersectPoint = intersects[0].point;
                    placementIndicator.position.set(intersectPoint.x, 0.1, intersectPoint.z); // Slightly above ground
                    placementIndicator.visible = true;
                     // TODO: Add check if placement is valid (not on path, etc.)
                } else {
                    placementIndicator.visible = false;
                }
            }
        }

        function onMouseClick(event) {
             // Important: Prevent building if clicking UI elements
             if (event.target.closest('#ui') || event.target.closest('#build-panel')) {
                return;
            }

            if (buildMode) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects([scene.children.find(c => c.geometry instanceof THREE.PlaneGeometry)]); // Intersect only ground plane

                if (intersects.length > 0) {
                    const intersectPoint = intersects[0].point;

                    // Simple check: Don't build too close to the path (example)
                    const pathCheckDistance = 2.0; // Minimum distance from path center line
                    if (Math.abs(intersectPoint.z - pathPoints[0].z) < pathCheckDistance) {
                         setBuildMessage("Nelze stavět na cestě nebo příliš blízko!", "red");
                         return; // Invalid placement
                    }

                    // Simple check: Don't build too close to other towers
                    const minTowerDistanceSq = 4.0 * 4.0; // Minimum distance between tower centers (squared)
                    let tooClose = false;
                    for(const tower of towers) {
                        const distSq = tower.body.position.distanceSquared(intersectPoint);
                        if (distSq < minTowerDistanceSq) {
                            tooClose = true;
                            break;
                        }
                    }
                     if (tooClose) {
                        setBuildMessage("Nelze stavět příliš blízko jiné věže!", "red");
                         return; // Invalid placement
                     }


                    // Attempt to create the tower
                     const newTower = createTower(intersectPoint);
                    if (newTower) { // If tower was successfully created (enough money)
                        // Optionally keep build mode active, or disable it
                        // toggleBuildMode(); // Disable build mode after placing one tower
                        // Or keep it active but update message / check money
                         if (money < TOWER_COST) {
                            setBuildMessage(`Nemáš dost peněz na další věž (potřeba ${TOWER_COST})`, "red");
                            toggleBuildMode(); // Exit build mode if money runs out
                        } else {
                             setBuildMessage(`Věž postavena! Klikni znovu pro další, nebo zruš stavbu. Zbývá peněz: ${money}`, "lightgreen");
                        }
                    }
                     // If createTower returned null (not enough money), the message was already set inside it.
                }
                // Don't exit build mode automatically, let the user place multiple or cancel
            }
        }

        // --- UI Update ---
        function updateUI() {
            document.getElementById('money').innerText = money;
            document.getElementById('health').innerText = Math.max(0, health); // Don't show negative health
            document.getElementById('wave').innerText = wave;
        }

        // --- Game Over ---
        function triggerGameOver() {
            if (gameOver) return; // Prevent multiple triggers
            console.log("GAME OVER!");
            gameOver = true;
            document.getElementById('game-over').style.display = 'block';
             // Optionally stop physics? Or just stop updates in animate()
        }


        // --- Start ---
        init();

    </script>

</body>
</html>
